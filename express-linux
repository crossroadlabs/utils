#!/usr/bin/env python
import os
import subprocess
import sys
import re
import inspect
import getopt

def command(description="", arguments_count=1):
  def decorator(method):
    arg_s = inspect.getargspec(method)
    arg_l = arg_s.args[1:arguments_count+1]
    all_args = arg_s.args[1:]
    opts = filter(lambda arg: arg not in arg_l, all_args)
    args = filter(lambda arg: arg not in opts, all_args)

    opts = map(lambda o: { "name": o, "default": arg_s.defaults[all_args.index(o)-len(all_args)] } , opts)
    
    def parse_opts_and_args(args):
      gopts = []
      for opt in opts:
        if type(opt["default"]) is bool:
          gopts.append(opt["name"])
        else:
          gopts.append(opt["name"]+"=")

      return getopt.gnu_getopt(args, "", gopts)

    method.__parse_opts_and_args = parse_opts_and_args
    method.__args = args
    method.__opts = opts
    method.__descr = description

    return method
  return decorator

def run_command(name, params=[], cwd=None, shell=False):
  if shell:
    subprocess.check_call(name, stdout=sys.stdout, stderr=sys.stderr, cwd=cwd, shell=shell)
  else:
    run_params = [name]
    run_params.extend(params)
    subprocess.check_call(run_params, stdout=sys.stdout, stderr=sys.stderr, cwd=cwd, shell=shell)


class Commandant(object):
  def __init__(self):
    cmds = []
    for name, func in inspect.getmembers(self, predicate=inspect.ismethod):
      if getattr(func, "__parse_opts_and_args", None) is not None:
        cmds.append(name)
    self.__commands = cmds

  @command("print this help")
  def help(self, command=""):
    if command == "":
      print "============================\n", "Help", "\n", "============================\n"
      for cmd in self.__commands:
        print "\t", cmd.replace("_", "-"), "\t\t\t", getattr(getattr(self, cmd), "__descr")
    else:
      print "============================\n","Help for", command, "\n", "============================\n"
      doc = inspect.getdoc(getattr(self, command, None))
      if doc is None:
        doc = getattr(getattr(self, command), "__descr")
      print doc
      print ""
      print "\tArguments:", ", ".join(getattr(getattr(self, command), "__args")), "\n"
      for opt in getattr(getattr(self, command), "__opts"):
        print "\tOption: ", "--"+opt["name"]+",", "default:", opt["default"] 

  def run_command_with_args(self, command, args):
    if command is None:
      self.help()
      return
    cmd = getattr(self, command.replace("-", "_"))
    if cmd is None:
      print "Error: Command not found"
      return
    popts, pargs = getattr(cmd, "__parse_opts_and_args")(args)
    popts = dict(popts) if popts is not None else {}
    pargs = pargs if pargs is not None else []
    args = map(lambda a, r: (a, r), getattr(cmd, "__args"), pargs)[:min(len(getattr(cmd, "__args")), len(pargs))]
    opts = []
    for opt in getattr(cmd, "__opts"):
      if type(opt["default"]) is bool:
        if popts.get("--"+opt["name"]) is not None:
          opts.append((opt["name"], True))
      else:
        opts.append((opt["name"], popts.get("--"+opt["name"], opt["default"])))
    params = dict(args+opts)
    cmd(**params)


class CLITool(Commandant):
  def __get_product_name(self, path):
    with open(path+"/Package.swift", "rt") as f:
      return re.search('Package\s*\(\s*name\s*:\s*"(.+?)"\s*[,\)]', f.read().decode("utf8")).group(1)

  @command("build project")
  def build(self, configuration="debug", dispatch=False, path="."):
    """ Builds product with Swift Package Manager """
    path = os.path.abspath(path)
    if dispatch:
      run_command("/usr/bin/env", ["swift", "build", "-c", configuration, "-Xcc", "-fblocks", "-Xswiftc", "-Ddispatch"], cwd=path)
    else:
      run_command("/usr/bin/env", ["swift", "build", "-c", configuration])

  @command("run project")
  def run(self, configuration="debug", path="."):
    path = os.path.abspath(path)
    run_command(path+"/.build/"+configuration+"/app", cwd=path)

  @command("remove builds or packages", 0)
  def clean(self, full=False, path="."):
    path = os.path.abspath(path)
    if full:
      run_command("rm", ["-rf", ".build", "Packages"], cwd=path)
    else:
      run_command("rm", ["-rf", ".build"], cwd=path)

  @command("initialise new Express project")
  def init(self, name, path=".", template="https://github.com/crossroadlabs/ExpressTemplate.git"):
    path = os.path.join(os.path.abspath(path), name)
    run_command("/usr/bin/env", ["git", "clone", template, path])
    run_command("rm -rf .git *.xcodeproj README* LICENSE* NOTICE*", cwd=path, shell=True)
    pname = self.__get_product_name(path)
    with open(path+"/Package.swift", "r+") as f:
      data = f.read().decode("utf8")
      data = data.replace('"'+pname+'"', '"'+name+'"')
      f.seek(0)
      f.truncate(0)
      f.write(data.encode("utf8"))
    print "Inititialized", name, "successfully."

  @command("build dependencies", 0)
  def build_deps(self, path="."):
    run_command("/usr/bin/env", ["swift", "build", "--fetch"], cwd=os.path.abspath(path))
    run_command("rm -rf Packages/*/Tests", cwd=path, shell=True)


#===================
# Main function
#===================
if __name__ == "__main__":
  cli = CLITool()
  if len(sys.argv) > 1:
    cmd = sys.argv[1]
  else:
    cmd = None
  if len(sys.argv) > 2:
    args = sys.argv[2:]
  else:
    args = None
  cli.run_command_with_args(cmd, args)
